
// Heterosporous fern.
// Two mutationTypes defined:
//   - m1 applies to gameto only
//   - m2 applies to sporo only

initialize() {

  // model type
  initializeSLiMModelType("nonWF");

  // config
  initializeRecombinationRate(1e-08, 15000000);
  initializeMutationRate(5e-8);
  initializeTreeSeq(simplificationInterval=200);

  // MutationType init
  initializeMutationType('m1', 0.5, 'f', 0.1);
  initializeMutationType('m2', 0.5, 'f', 0.1);

  // ElementType init
  initializeGenomicElementType('g1', m1, 1.0);
  initializeGenomicElementType('g2', m2, 1.0);

  // Chromosome (GenomicElement init)
  initializeGenomicElement(g1, 5000001, 5001000);
  initializeGenomicElement(g2, 10000001, 10001000);

  // constants (Population sizes and others)
  defineConstant('SPO_POP_SIZE', 3000);
  defineConstant('GAM_POP_SIZE', 3000);
  defineConstant('SPO_MUTATION_RATE', 5e-08);
  defineConstant('GAM_MUTATION_RATE', 5e-08);
  defineConstant('GAM_CLONE_RATE', 0.00);
  defineConstant('GAM_CLONES_PER', 1);
  defineConstant('SPO_CLONE_RATE', 0.00);
  defineConstant('SPO_CLONES_PER', 1);
  defineConstant('SPO_SELF_RATE_PER_EGG', 0.00);
  defineConstant('SPO_SELF_RATE_PER_IND', 0.00);
  defineConstant('SPO_RANDOM_DEATH_CHANCE', 0);
  defineConstant('GAM_RANDOM_DEATH_CHANCE', 0);
  defineConstant('SPO_MATERNAL_EFFECT', 0);
  defineConstant('GAM_ARCHEGONIA_PER', 10);
  defineConstant('SPO_MICROSPORES_PER', 20);    // <--- this parameter slows it down a lot when high
  defineConstant('SPO_MEGASPORES_PER', 10);

  // extra scripts (Optional)
  
}

// shadie DEFINITIONS
// p0 = haploid population
// p1 = diploid population


// 1 = gametophyte male (microspore)
// 2 = gametophyte female (megaspore)
// 11 = gametophyte cloned male
// 22 = gametophyte cloned female
// 3 = sporophyte 2N (non-clonal)
// 33 = sporophyte clone 2N
// Note: sporophyte selfing occurs by gametophytes finding mates from same parent.


// executes after reproduction block in NONWF (after offspring are generated).
// define subpops: p1=diploid sporophytes, p0=haploid gametophytes
1 early() {
    sim.addSubpop('p1', SPO_POP_SIZE);
    sim.addSubpop('p0', 0);
    p1.individuals.tag = 3;
}


early() {
    // reproduction(p1) just finished creating gametophytes in p0.
    // this generation will calculate fitness and apply selection on them.
    if (sim.generation % 2 == 0) {

        // fitness is scaled relative to ...
        num_females = length(p0.individuals[p0.individuals.tag == 2]);
        num_females = num_females + length(p0.individuals[p0.individuals.tag == 22]);
        p0.fitnessScaling = (GAM_POP_SIZE / (num_females));

        // set mutation rate to gametophyte rate
        sim.chromosome.setMutationRate(GAM_MUTATION_RATE);

        // alternate generations.
        // deactivate survival callback to remove inds from p1 subpop.
        // activate survival callback to remove inds from p0 subpop.
        s1.active = 1;
        s2.active = 0;

        // add random chance of death, maternal effects, or fitness calculation.
        // activate survival(p0) to set fitness method for p0s
        // deactivate survival(p1) to set fitness method for p1s
        s3.active = 1;
        s4.active = 0;

        // set reproduction function to be used when next generation starts.
        // deactivate reproduction(p1) diploids reproduce, haploids don't.
        // activate reproduction(p0) haploids reproduce, diploids don't.        
        s5.active = 0;
        s6.active = 1;

        // Each of the callbacks below applies to a MutationType's fitness effect.
        // This can one of three possible effects depending on the shadie code:

        // x0. perform non-standard fitness calc to suppress all effects (can apply to diploids or haploids)
        // x1. perform non-standard fitness calc to suppress dominance (should only be applied to haploids)
        // X2. perform standard fitness calc (should only be applied to diploids)

        // m1 has non-dominance fitness effect on gametophyte
        s70.active = 0;
        s71.active = 1;
        s72.active = 0;

        // m2 has no effect on gametophyte
        s80.active = 1;
        s81.active = 0;
        s82.active = 0;
    }

    // reproduction(p0) just finished creating diploid zygotes in p1
    // to a level that is likely above its carrying capacity. Next
    // fitness will be calculated and seletion applied to sporophytes.
    else {

        // fitness is scaled relative to number of inds in p1
        p1.fitnessScaling = SPO_POP_SIZE / p1.individualCount;

        // set mutation rate to sporophyte rate
        sim.chromosome.setMutationRate(SPO_MUTATION_RATE);

        // alternate generations.
        // deactivate survival(p0) to remove inds from p0 subpop (i.e., keep p0)
        // activate survival(p1) to remove inds from p1 subpop.
        s1.active = 0;
        s2.active = 1;

        // add random chance of death, maternal effects, or fitness calculation.
        // deactivate survival(p0) to set fitness method for p0s
        // activate survival(p1) to set fitness method for p1s
        s3.active = 0;
        s4.active = 1;

        // set reproduction function to be used when next generation starts.
        // activate reproduction(p1) diploids reproduce, haploids don't.
        // deactivate reproduction(p0) haploids reproduce, diploids don't.        
        s5.active = 1;
        s6.active = 0;

        // x0. perform non-standard fitness calc to suppress all effects (can apply to diploids or haploids)
        // x1. perform non-standard fitness calc to suppress dominance (should only be applied to haploids)
        // X2. perform standard fitness calc (should only be applied to diploids)

        // m1 has no effect on sporophyte
        s70.active = 1;
        s71.active = 0;
        s72.active = 0;

        // m2 has standard fitness effect on sporophyte
        s80.active = 0;
        s81.active = 0;
        s82.active = 1;
    }
}



// alternate to other generation.
// remove p1 individuals unless it is a clone
s1 survival(p1) {
    if (individual.tag == 33) {
        individual.tag = 3;
        return T;
    }
    return F;
}

// alternate to other generation.
// remove p0 individuals unless it is a clone.
s2 survival(p0) {
    if (individual.tag == 11) {
        individual.tag = 1;
        return T;
    }
    else if (individual.tag == 22) {
        individual.tag = 2;
        return T;
    }
    return F;
}

// remove p0s by three possible mechanisms: 
// 1. random chance of death.
// 2. using fitness re-calculated to include maternal effect.
// 3. returns NULL, meaning use the standard fitness prob.
s3 survival(p0) {
    if (runif(1) < GAM_RANDOM_DEATH_CHANCE)
        return F;
    maternal_effect = individual.getValue("maternal_fitness");
    if (!isNULL(maternal_effect)) {
        corrected_fitness = (maternal_effect * SPO_MATERNAL_EFFECT) + fitness * (1 - SPO_MATERNAL_EFFECT);
        return (runif(1) < corrected_fitness);
    }
    return NULL;
}


// remove p1s by three possible mechanisms: 
// 1. random chance of death.
// 2. using fitness re-calculated to include maternal effect.
// 3. returns NULL, meaning use the standard fitness prob.
s4 survival(p1) {
    if (runif(1) < SPO_RANDOM_DEATH_CHANCE)
        return F;
    maternal_effect = individual.getValue("maternal_fitness");
    if (!isNULL(maternal_effect)) {
        corrected_fitness = (maternal_effect * GAM_MATERNAL_EFFECT) + fitness * (1 - GAM_MATERNAL_EFFECT);
        return (runif(1) < corrected_fitness);
    }
    return NULL;
}


// each sporophyte (2N) undergoes meiosis to create spores (1N) that 
// are recombinant products and develop within special structures 
// as microspores (tag=01) or megaspores (tag=02).
s5 reproduction(p1) {

    // sporophyte is non-clonal and non-selfing
    if (individual.tag == 3) {

        // probability this individual makes sporophyte clones


        // probability this individual makes sporophytic selfed offspring


        // individual can create gametophytes with remaining non-selfed 
        make_megaspores(individual, SPO_MEGASPORES_PER);
        make_microspores(individual, max(4, SPO_MICROSPORES_PER));
    }

    // sporophytic clone
    else if (individual.tag == 11) {
        make_megaspores(individual, SPO_MEGASPORES_PER);
        make_microspores(individual, max(4, SPO_MICROSPORES_PER));
        for (i in 1:SPO_CLONES_PER)
            p1.addCloned(individual).tag = 11;
    }

    // sporophyte with (some) selfing and some 
    else if (individual.tag == 10) {}

    // sporophyte creates clones for next generation
    // and also creates eggs & sperms this generation
    if (individual.tag == 44) {
        for (i in 1:SPO_CLONES_PER)
            p1.addCloned(individual).tag = 44;
        make_eggs(individual, SPO_MEGASPORES_PER);
        make_microspores(individual, max(4, SPO_MICROSPORES_PER));
    }

    // sporophytic selfed only
    if (individual.tag == 5)
        sporophyte_selfs(individual);

    // sporophytic cloned and selfed
    if (individual.tag == 45) {
        for (i in 1:SPO_CLONES_PER)
            p1.addCloned(individual).tag = 44;
        sporophyte_selfs(individual);
    }
}


// gametophyte gametes are joined to form new 2N sporophytes.
// 
// generates p1 offspring and p0 clones
// reproduction in p0: eggs are fertilized by sperm.
s6 reproduction(p0) {

    // female gametophyte (megaspore)
    if (individual.tag == 2) {
               
        // can produce multiple mitotically identical eggs
        for (rep in 1:GAM_ARCHEGONIA_PER) {

            // gametophytic selfing: NONE; heterosporous fern cannot.

            // sporophytic selfing: same-sporo-parent as male gametophyte sperm donor.

            // outcrossing: random male gametophyte (microspore) as a sperm donor.
            sperm = p0.sampleIndividuals(1, tag=01);

            // add new p1 sporophyte tag=0 (hermaph)
            child = p1.addRecombinant(individual.genome1, NULL, NULL, sperm.genome1, NULL, NULL);
            child.tag=0;
        }
    }

    // if gametophyte is a clone (tag=4), add its genome to next gen's p0
    // this will get retagged to 0 in s4 survival.
    else if (individual.tag == 4) { 
        for (i in 1:GAM_CLONES_PER)
            p0.addRecombinant(individual.genome1, NULL, NULL, NULL, NULL, NULL).tag = 4;
    }
}


// adjusts fitness calculation
// This applies to p0 and overrides the standard fitness calculation, 
// which would incorporate the dominanceCoefficient for heterozygotes.
s70 fitness(m1) {
    return 1.0;
}

s71 fitness(m1) {
    return 1.0 + mut.selectionCoeff;
}

s72 fitness(m1) {
    if (homozygous)
        return 1.0 + mut.selectionCoeff;
    else
        return 1.0 + mut.mutationType.dominanceCoeff * mut.selectionCoeff;
    }


// adjusts fitness calculation
// This applies to p0 and overrides the standard fitness calculation, 
// which would incorporate the dominanceCoefficient for heterozygotes.
s80 fitness(m1) {
    return 1.0;
}

s81 fitness(m1) {
    return 1.0 + mut.selectionCoeff;
}

s82 fitness(m1) {
    if (homozygous)
        return 1.0 + mut.selectionCoeff;
    else
        return 1.0 + mut.mutationType.dominanceCoeff * mut.selectionCoeff;
    }


// executes after selection occurs
// end of sim; save .trees file
101 late() {
    report();
    sim.treeSeqRememberIndividuals(p1.individuals);
    sim.treeSeqOutput(
        path='/tmp/target-fern-hetero.trees',
        metadata=Dictionary(
            "spo_mutation_rate", SPO_MUTATION_RATE,
            "recombination_rate", 1e-7,
            "spo_population_size", SPO_POP_SIZE,
            "gam_population_size", GAM_POP_SIZE)
    );
}

// executes after selection occurs. Retagging of individuals to act
// as cloners or selfers in the next generation, and fixes removes
// fixed mutations for speed/mem purposes.
late() {
    // gametophytes have just undergone fitness selection
    if (sim.generation % 2 == 0) {

        // tag individuals that will make male gametophytes clones
        nsamples = asInteger(size(p0.individuals) * GAM_CLONE_RATE);
        clones = p0.sampleIndividuals(nsamples, tag=01);
        clones.tag = 011;

        // tag individuals that will make female gametophytes clones
        nsamples = asInteger(size(p0.individuals) * GAM_CLONE_RATE);
        clones = p0.sampleIndividuals(nsamples, tag=02);
        clones.tag = 022;
    }

    // sporophytes have just undergone fitness selection
    else {
        // tag sporophytes that will clone (11)
        nsamples = asInteger(size(p1.individuals) * SPO_CLONE_RATE);
        clones = p1.sampleIndividuals(nsamples, tag=1);
        clones.tag = 11;

        // tag sporophytes that will self (10)
        nsamples = asInteger(size(p1.individuals) * SPO_SELF_RATE_PER_IND);        
        selfed = p1.sampleIndividuals(nsamples, tag=1);
        selfed.tag = 10;
    }

    // logger
    if (sim.generation % 10 == 0)
        report();
}




// DEBUGGING and removing fixed mutations.
function (void)report(void) {

    // get the total number of genomes
    ngenomes = (2 * size(p1.individuals)) + size(p0.individuals);
    cat(format('gen=%i, ', sim.generation));
    cat(format('ngenomes=%i, ', ngenomes));
    cat(format('(p1.tag0=%i, ', 2 * p1.individuals.size()));
    cat(format('p1.tag44=%i, ', sum(p1.individuals.tag == 44)));
    cat(format('p1.tag5=%i, ', sum(p1.individuals.tag == 5)));
    cat(format('p1.tag45=%i, ', sum(p1.individuals.tag == 45)));
    cat(format('p0.tag0=%i, ', sum(p0.individuals.tag == 0)));
    cat(format('p0.tag1=%i, ', sum(p0.individuals.tag == 1)));
    cat(format('p0.tag2=%i, ', sum(p0.individuals.tag == 2)));
    cat(format('p0.tag4=%i, ', sum(p0.individuals.tag == 4)));
    cat(format('p0.tag6=%i)\n', sum(p0.individuals.tag == 6)));

    // iterate over mutationTypes in the simulation
    for (mtype in sim.mutationTypes) {

        // get all mutations of this type
        muts = sim.mutationsOfType(mtype);

        // 
        for (mut in muts) {
            counts = sim.mutationCounts(NULL, mut);
            cat(mut);
            cat(format('; counts=%i\n', counts));
            if (counts == ngenomes) {
                sim.subpopulations.genomes.removeMutations(mut, T);
            }
        }
    }
    cat("\n-------------------------- fixed=" + sim.substitutions.size() + "\n\n");
}


// shadie func(ind, reps) to generate 4 p0 tag=2 (male/microspores) in heterosporous ferns.
// Each ind here represents a 2N microsporangium, and each replicate is a different 
// mitotic 2N sporocyte that it produces. Each sporocyte undergoes meiosis to 
// form 4 1N recombinant gametes (microspores) that are added to p0.
function (void)make_microspores(object<Individual>$ ind, integer$ reps) {
    for (rep in 1:reps){

        // 4 microspores per meiosis rep
        breaks1 = sim.chromosome.drawBreakpoints(individual);
        breaks2 = sim.chromosome.drawBreakpoints(individual);
        child1 = p0.addRecombinant(individual.genome1, individual.genome2, breaks1, NULL, NULL, NULL);
        child2 = p0.addRecombinant(individual.genome2, individual.genome1, breaks1, NULL, NULL, NULL);
        child3 = p0.addRecombinant(individual.genome1, individual.genome2, breaks2, NULL, NULL, NULL);
        child4 = p0.addRecombinant(individual.genome2, individual.genome1, breaks2, NULL, NULL, NULL);

        // create vector of all recombined children genomes
        children = c(child1, child2, child3, child4);
        children.tag = 01;

        // set fitness so that mother affects gametophyte fitness; see survival()
        if (SPO_MATERNAL_EFFECT > 0)
            children.setValue("maternal_fitness", individual.subpopulation.cachedFitness(individual.index));
    }
}


// shadie func(ind, reps) to generate 1 p0 tag=1 (female/egg) in heterosporous fern
function (void)make_megaspores(object<Individual>$ ind, integer$ reps) {
    for (rep in 1:reps){
        breaks = sim.chromosome.drawBreakpoints(individual);
        child1 = p0.addRecombinant(individual.genome1, individual.genome2, breaks, NULL, NULL, NULL);
        child1.tag = 02;

        // set fitness so that mother affects gametophyte fitness; see survival()
        if (SPO_MATERNAL_EFFECT > 0)
            child1.setValue("maternal_fitness", individual.subpopulation.cachedFitness(individual.index));
    }
}


// shadie func(ind) to sporophytic self in heterosporous fern
// generates p1 tag=5 (self) selfed sporophytes
// generates p0 tag=0 (herm) gametophytes, and p0 tag=1 or tag=2 (eggs, sperm)
function (void)sporophyte_selfs(object<Individual>$ ind) {
    
    // count the number of eggs that are selfed, only the unselfed ones
    // will be added to the p0 pool.
    selfed_eggs = 0;

    // iterate over megaspores per megasporangia
    for (i in 1:SPO_MEGASPORES_PER) {

        // heterosporous ferns have 1-few archegonia (and thus egg) per megasporangium
        for (i in 1:GAM_ARCHEGONIA_PER) {

            // randomly sample whether this egg was self fertilized
            if (runif(1) < SPO_SELF_RATE_PER_EGG) {
                selfed_eggs = selfed_eggs + 1;
                
                // NOTE: this seems odd...

                // create 4 self sperm, use one of them to create new p1 zygote,
                // put other 3 sperm into the gamete pool.
                breaks1 = sim.chromosome.drawBreakpoints(individual);
                breaks2 = sim.chromosome.drawBreakpoints(individual);
                breaks_f = sim.chromosome.drawBreakpoints(individual);
                p1.addRecombinant(ind.genome1, ind.genome2, breaks1, ind.genome1, ind.genome2, breaks_f).tag = 5;

                // TODO: if these are extra sperm why are they not tag=2?
                // 4 gametophytes that produce antheridia per meiosis
                child1 = p0.addRecombinant(ind.genome2, ind.genome1, breaks1, NULL, NULL, NULL);
                child2 = p0.addRecombinant(ind.genome1, ind.genome2, breaks2, NULL, NULL, NULL);
                child3 = p0.addRecombinant(ind.genome2, ind.genome1, breaks2, NULL, NULL, NULL);

                // save all children produced to vector
                children = c(child1, child2, child3);
                children.tag = 0;

                // mother's fitness affects gametophyte fitness; see survival()
                if (SPO_MATERNAL_EFFECT > 0)
                    children.setValue("maternal_fitness", ind.subpopulation.cachedFitness(individual.index));
            }
            else
                make_eggs(individual, 1);
        }
    }

    // gametophyte is male: make microspores minus the ones already used in selfing.
    make_microspores(individual, SPO_MICROSPORES_PER - selfed_eggs);
}
